# Для второго способа решения мы будем использовать динамическое программирование.
# Теперь для каждого следующего числа мы будем находить не все возможные суммы,
# а только сумму всех чисел до этого числа вкл (префиксная сумма).
# Полученные суммы запишем в список, для того чтобы можно было найти сумму любой последовательности
# через разность текущей префиксной суммы и записанной ранее.
# Искать же сумму последовательности мы будем только в том случае, если эта сумма делится на 89
# Предположим, что текущая префиксная сумма 9002, остаток от деления на 89 будет 13, тогда,
# чтобы получить сумму делящуюся на 89, нам нужно вычесть префиксную сумму с таким же остатоком
# например 102 (102 % 89 = 13), 9002 - 102 = 8900 (8900 % 89 = 0).
# Таким образом, чтобы получить максимальную сумму последовательности, нам достаточно хранить
# минимальные префиксные суммы для каждого возможного остатка
# Вычитая из текущей префиксной суммы, минимальную с таким же остатком, что и у текущей
# мы будем получать максимально возможную сумму, делящуюся на 89.
# Однако стоит помнить, что минимальная префиксная сумма для остатка 0 это первое число, которое делится на 89,
# а значит, если текущая префиксная сумма делится на 89, из неё не нужно вычитать этот элемент,
# ведь это не изменит делимости, но уменьшит итоговую сумму.

f = open("27_B.txt")        # Откроем файл с исходными данными
n = int(f.readline())       # Прочитаем первую строчку (количество чисел)
nums = [int(s) for s in f]     # Создадим список и запишем в него все числа

pref_summ, summ, max_summ, len_max_summ = 0, 0, -1, 999999999

# Создадим список, в котором каждый элемент будет указывать на остаток от деления на 89,
# причем индекс элемента списка соответствует остатку от деления,
# каждый элемент также является списком, состоящим из: префиксной суммы,
# которая дает данный остаток от деления, индекс последнего добавленного числа и само число.
rems = [[999999999, 0]]*89

for i in range(n):
    pref_summ += nums[i]        # прибавляем текущее число к префиксной сумме
    rem = (pref_summ % 89)      # находим остаток для текущей префиксной суммы
    # Если префиксная сумма минимальна для данного остатка, запишем в список
    # префиксную сумму, индекс текущего числа и само число
    if pref_summ < rems[rem][0]:
        rems[rem] = [pref_summ, i]

    # Сумма последовательности = текущая преф сумма - минимальная преф сумма с таким же остатком
    # !!! Если остаток 0, то минимальную преф сумму вычитать не нужно
    summ = pref_summ - (rems[rem][0] * (rems[rem][0] % 89 != 0))
    # Если сумма обновляет максимум, то обновим также и длину последовательности
    # !!! Если остаток 0, то последовательность включает и первое число делящееся на 89
    if summ > max_summ:
        max_summ = summ
        len_max_summ = i - rems[rem][1] + (rems[rem][0] % 89 == 0)
    # Если сумма равна максимуму, то проверим, какая последовательность будет короче и если нужно обновим длину
    if summ == max_summ:
        len_max_summ = min(len_max_summ, i - rems[rem][1] + (rems[rem][0] % 89 == 0))

# По итогу в len_max_summ будет лежать длина той последовательности,
# которая имеет максимальную сумму и минимальную длину
print(len_max_summ)

